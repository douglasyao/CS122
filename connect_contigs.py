### connect_contigs.py
# Connects contigs generated from assembly_debruijn.py using a greedy algorithm

from os.path import join
import zipfile
from assembly_debruijn import read_reads


# Reads contigs from file generated by assembly_debruijn.py
def read_contigs(read_fn):
    '''
    :param read_fn: File name
    :return: List of contigs
    '''
    with open(read_fn, 'r') as f:
        all_reads = f.readlines()
    all_reads = [x.strip() for x in all_reads]
    all_reads = all_reads[2:]
    return all_reads


# Combines several functions merge_contigs, orient_contigs, and get_consensus to collectively connect contigs
def connect_contigs(contigs, reads):
    '''
    :param contigs: List of contigs
    :param reads: List of reads used to generate contigs
    :return: List of connected contigs
    '''
    nreads = [item for sublist in reads for item in sublist]
    contigs, repeats = remove_duplicates(contigs)
    contigs = orient_contigs(contigs)
    new_contigs = []
    for curr_contig in contigs:
        forward_matching_reads = [x for x in nreads if curr_contig[-15:] in x]
        forward_matching_reads.extend([x[::-1] for x in nreads if curr_contig[-15:] in x[::-1]])
        back_matching_reads = [x for x in nreads if curr_contig[:15] in x]
        back_matching_reads.extend([x[::-1] for x in nreads if curr_contig[:15] in x[::-1]])
        locations = map_reads_to_ref(curr_contig, forward_matching_reads, back_matching_reads, 15)
        new_contig = get_consensus(curr_contig, locations)
        new_contigs.append(new_contig)

    new_contigs = orient_contigs(new_contigs)
    new_contigs, repeats = remove_duplicates(new_contigs)
#    new_contigs = merge_contigs(new_contigs)
    return new_contigs


# Looks for overlapping sections between contigs and attempts to connect them if they overlap
def merge_contigs(contigs):
    '''
    :param contigs: List of contigs
    :return: List of connected contigs
    '''
    new_contigs = []
    curr_contig = contigs[0]
    contigs.remove(curr_contig)
    while True:
        forward_contigs = [x for x in contigs if curr_contig[-25:] in x]
        back_contigs = [x for x in contigs if curr_contig[:25] in x]
        if len(back_contigs) == 1 and len(forward_contigs) == 1:
            if back_contigs[0] == forward_contigs[0]:
                match = back_contigs[0].find(curr_contig[:25])
                toadd = back_contigs[0][:match] + curr_contig
                contigs.remove(back_contigs[0])
                curr_contig = toadd
            else:
                backmatch = back_contigs[0].find(curr_contig[:25])
                formatch = forward_contigs[0].find(curr_contig[-25:])
                toadd = back_contigs[0][:backmatch] + curr_contig + forward_contigs[0][formatch:]
                contigs.remove(back_contigs[0])
                contigs.remove(forward_contigs[0])
                curr_contig = toadd
        elif len(back_contigs) == 1:
            match = back_contigs[0].find(curr_contig[:25])
            toadd = back_contigs[0][:match] + curr_contig
            contigs.remove(back_contigs[0])
            curr_contig = toadd
        elif len(forward_contigs) == 1:
            match = forward_contigs[0].find(curr_contig[-25:])
            toadd = curr_contig + forward_contigs[0][match:]
            contigs.remove(forward_contigs[0])
            curr_contig = toadd
        else:
            new_contigs.append(curr_contig)
            if not contigs:
                break
            else:
                curr_contig = contigs[0]
                contigs.remove(curr_contig)

    return new_contigs


# Attempts to orient all contigs in the same direction (some may be backwards at first)
def orient_contigs(contigs):
    '''
    :param contigs: List of contigs
    :return: List of properly oriented contigs
    '''
    curr_contig = contigs[0]
    contigs.remove(curr_contig)
    new_contigs = [curr_contig]
    while True:
        forward_contigs = [x for x in contigs if curr_contig[-15:] in x]
        forward_contigs.extend([x[::-1] for x in contigs if curr_contig[-15:] in x[::-1]])
        back_contigs = [x for x in contigs if curr_contig[:15] in x]
        back_contigs.extend([x[::-1] for x in contigs if curr_contig[:15] in x[::-1]])
        combined = forward_contigs + back_contigs
        contigs = [x for x in contigs if x not in combined and x[::-1] not in combined]
        if not contigs:
            break
        new_contigs.extend(combined)
        curr_contig = contigs[0]
        new_contigs.append(curr_contig)
        contigs.remove(curr_contig)
    return new_contigs


# If one contig is a subset of another contig, remove that contig
def remove_duplicates(contigs):
    '''
    :param contigs: List of contigs
    :return: List of pruned contigs
    '''
    contigs.sort(key = lambda x: len(x), reverse=True)
    repeats = list(set([x for x in contigs if contigs.count(x) > 3]))
    if repeats:
        curr_repeat = repeats[0]
        repeats.remove(curr_repeat)
        new_repeats = [curr_repeat]
        while True:
            repeats = [x for x in repeats if x[:10] not in curr_repeat and x[:10][::-1] not in curr_repeat]
            if not repeats:
                break
            curr_repeat = repeats[0]
            new_repeats.append(curr_repeat)
            repeats.remove(curr_repeat)

    curr_contig = contigs[0]
    contigs.remove(curr_contig)
    new_contigs = [curr_contig]
    while True:
        contigs = [x for x in contigs if x not in curr_contig and x[::-1] not in curr_contig]
        if not contigs:
            break
        curr_contig = contigs[0]
        new_contigs.append(curr_contig)
        contigs.remove(curr_contig)
    return new_contigs, repeats


# Attempts to extend contig by matching to reads using a greedy method
def get_consensus(ref, read_locations):
    '''
    :param ref: Contig sequence
    :param read_locations: List of reads and their relative alignment location to contig
    :return:
    '''
    read_locations.append([ref,0])
    bases = {}
    consensus = ''
    end = max([x[1] for x in read_locations]) + 50
    if end < len(ref):
        end = len(ref)
    start = min(x[1] for x in read_locations)
    length = end - start
    for x in range(len(read_locations)):
        read_locations[x][1] -= start
    for i in range(length):
        reads = {'A': 0, 'C': 0, 'G': 0, 'T': 0}
        bases[i] = reads
    for read, location in read_locations:
        for j in range(len(read)):
            if len(read) > 50:
                bases[location + j][read[j]] += 20
            else:
                bases[location + j][read[j]] += 1

    for i in range(0, len(bases)):
        maximum = max([bases[i][x] for x in bases[i]])
        to_add = [x for x in bases[i] if bases[i][x] > 15 and bases[i][x] > maximum/2]
        if len(to_add) > 1:
            if i < len(bases)/2:
                continue
            else:
                break
        elif to_add:
            consensus = consensus + to_add[0][0]
    return consensus


# Maps reads to a contig to determine relative alignment locations
def map_reads_to_ref(ref, forward_reads, backward_reads, end):
    '''
    :param ref: Contig sequence
    :param forward_reads: List of reads that match to the front (right) side of the contig
    :param backward_reads: List of reads that match to the back (left) side of the contig
    :param end: How far to match
    :return: List of all reads and their relative alignment locations to the contig
    '''
    all_locations = [[ref,0]]
    offset = len(ref) - 50
    if forward_reads:
        for read in forward_reads:
            index = 0
            while (index <= len(ref) - end):
                mismatches = sum([1 if ref[offset + i + index] != read[i] else 0 for i in range(len(read) - index)])
                if mismatches > 2:
                    index += 1
                else:
                    all_locations.append([read, offset+index])
                    break

    if backward_reads:
        for read in backward_reads:
            index = 0
            while (end - index <= len(read)):
                readend = len(read) + index
                if readend > len(ref):
                    readend = len(ref)
                mismatches = sum([1 if ref[j] != read[j - index] else 0 for j in range(readend)])
                if mismatches > 2:
                    index -= 1
                else:
                    all_locations.append([read, index])
                    break
    all_locations.remove([ref,0])
    return all_locations


if __name__ == "__main__":
    chr_name = 'hw3all_A_3_chr_1'
    input_folder = 'C:/Users/DWYao/Downloads/hw3all_A_3/'
    reads_fn = join(input_folder, 'reads_{}.txt'.format(chr_name))
    reads = read_reads(reads_fn)
    contig_fn = join(input_folder, 'assemble_temp_{}.txt'.format(chr_name))
    contigs = read_contigs(contig_fn)
    ans = connect_contigs(contigs, reads)
    ans.sort(key = lambda x: len(x), reverse=True)

    output_fn_end = 'assembled_{}.txt'.format(chr_name)
    output_fn = join(input_folder, output_fn_end)
    with open(output_fn, 'w') as output_file:
        output_file.write('>' + chr_name + '\n')
        output_file.write('>ASSEMBLY\n')
        output_file.write('\n'.join(ans))
    zip_fn = join(input_folder, 'assembled_{}.zip'.format(chr_name))
    with zipfile.ZipFile(zip_fn, 'w') as myzip:
        myzip.write(output_fn)
